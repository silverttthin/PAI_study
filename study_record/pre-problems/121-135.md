# 5장 리스트, 딕셔너리  

1학년 때 파이썬 첨 배웠을 때 노션에 필기해둔 내용 (각각 리스트, 딕셔너리):   
https://band-baseball-d12.notion.site/f9c340b663484dd49ff107276a4c576d
https://band-baseball-d12.notion.site/f7fcd611b84f46efa24fd6a842dbc12f
## 리스트

순서대로 저장하는 시퀸스이자 변경 가능한 목록.   
입력 순서가 유지되며 내부적으로 동적 배열로 구현돼있다. (동적 배열은 추후에 다시..)  
각 언어별 동적 배열 구현:  
1. C++ -> std::vector  
2. Python -> list()
3. JAVA -> ArrayList
<br>  

리스트는 다양한 기능을 제공하면서도 O(1)로 실행 가능한 연산들도 몇가지 존재한다.  
|연산|시간복잡도|설명|
|---|---|---|
|len(a)|O(1)|전체 요소 개수 리턴|
|a[i]|O(1)|인덱스 i의 요소 가져옴|
|a[i:j]|O(k)|i부터 j까지 슬라이스 길이(k)만큼 k개의 요소를 가져옴|
|elem in a|O(n)|요소가 안에 있는지 확인|
|a.count(elem)|O(n)|요소의 개수를 리턴|
|a.index(elem)|O(n)|요소의 인덱스 리턴|
|a.append(elem)|O(1)|리스트 마지막에 요소 추가|
|a.pop()|O(1)|리스트의 마지막 요소를 추출한다. 스택 연산이다|
|a.pop(0)|O(n)|리스트의 첫번째 요소를 추출한다. 큐 연산이다|
|del a[i]|O(n)|i번째 요소 삭제한다. i에 따라 다르며 최악이 O(n)이다|
|a.sort()|O(nlog n)|정렬한다. 팀소트를 사용하며 최선의 경우 O(n)이다|
|min(a), max(a)|O(n)|최소/최대값 찾기 위해선 전체를 선형탐색 해야한다|
|a.reverse()|O(n)|뒤집는다.|

시간복잡도 순서가 헷갈리면 BokSoup:  
*O(1)>O(log n)>O(n)>O(nlog n)> O(n<sup>2</sup>)>O(2<sup>n</sup>)>O(n!)*  

---

<br>

### 활용법

```Python
a=list()

a = []  
```
*선언*은 다음과 같이한다. 주로 두번째 방식으로 간단히 선언한다.   
<br>

```python
a = [1,2,3]
a.append(4) # a = [1,2,3,4]

a.insert(3,5) # a = [1,2,3,5,4]
```
append 함수로 마지막에 4라는 요소를 **덧붙인다**.  

insert 함수로 3번째 인덱스에 5라는 값을 **삽입한다**.  

숫자만 넣었지만 문자열, boolean 등 다양한 값을 넣을 수 있다.  
<br>

```python
a = [0,1,2,3,4,5,6]


a[1:3] # >>> [1,2]

a[:3] # >>> [0,1,2]

a[4:] # >>> [4,5,6]

a[1:6:2] # >>> [1,3,5]

# 슬라이싱은 추후에 더 깊게 알아볼 것.
```
**슬라이싱 기능**은 리스트는 물론 문자열에서도 매우 유용하게 사용된다.
a:b은 <u>a이상 b 미만의 인덱스</u>를 가져오라는 의미이다. 맨 처음이나 맨 끝은 생략 가능하다.  
세번째 인자를 넣을 경우 읽어오는 값을 가져올 때 건너는 칸을 설정한다.(기본은 1로 돼있음.)  
<br>  

```python
a=[0,1,2,3,4,5]
#1. 인덱스로 지정하기(del 함수)
del a[4] # a = [0,1,2,3,5]

#2. 값으로 지정하기(remove 함수)
a.remove(3) # a= [0,1,2,5]

# 추가: 추출값 리턴 후 삭제(pop 함수)
pop_return_value = a.pop(2) # a = [0,1,5]
print(pop_return_value) # 2 
```
요소를 삭제하는 대에는 2가지 방법이 있다.  
del 키워드를 사용하여 **인덱스를 지정**해 삭제하거나  
remove 함수를 사용해 **값을 지정**해 삭제할 수 있다.  

pop함수로 추출하여 **리턴값으로 활용**할 수도 있다.  
<br>

+) del은 함수와는 좀 다른 모양인데 함수인가? -> del은 함수처럼 기능하긴 한다.. 객체를 삭제하는 파이썬의 keyword라고 이해해두자.  

---  

<br><br>

## 딕셔너리

Key - Value 값 구조로 이뤄진 딕셔너리 구조.  
3.7+에서 입력 순서가 유지되며 내부적으로 해시 테이블로 구현돼 있다.(해테는 추후에..)  
각 언어별 해시 테이블:  
1. C++ -> std::unordered_map  
2. Python -> dict()
3. JAVA -> HashMap
<br>  

파이썬 딕셔너리에선 숫자, 문자, 집합 등의 **모든 불변 객체를 키로 사용** 할 수 있다.  
또한 관련연산 대부분이 O(1)에 가능하다.
|연산|시간 복잡도|설명|
|---|---|---|
|len(a)|O(1)|요소 개수 리턴|
|a[key]|O(1)|key를 조회해 값 리턴|
|a[key] =  value|O(1)|key/value 값을 삽입|
|key in a|O(1)|딕셔너리에 key가 존재하는지 조회|

---  

### 활용법  
파이썬 3.6+에서는 딕셔너리 메모리 성능개선이, 3.7+에서는 입력 순서 유지 패치가 이뤄졌다. 즉, 3.7 이전 버전에서는 입력 순서가 유지되지 않으니 유의해야한다.  
<br>
딕셔너리를 효율적으로 사용키 위해 파이썬 자체에서 추가 모듈을 지원해준다. collection 모듈에서 지원하는 기능들은 앞으로 유용히 쓰일 것이다. 배울 것도 2개밖에 없다.  

```python
a = {'key1':'value1', 'key2':'value2'} # dict() 함수로도 선언 가능

# 키/값 추가
a['key3'] = 'value3'

a['key2']  # >>> 'value2'
```

다음처럼 매우 쉽게 사용 가능하다. 한가지 경험으로 ':' 과 '=' 헷갈릴 수 있다.

```python
for k, v in a.items():
    print(k, v)

del a['key1']
```
items 메소드를 사용하면 해당 딕셔너리의 key, value 로 값을 가지는 튜플이 담긴 리스트를 리턴한다.  
또한 리스트처럼 del 키워드를 사용해 키를 삭제할 수 있다.  

---

### 활용법 - 딕셔너리 모듈 (defaultdict, Counter, OrderedDict)  
import collections 해줘야 한다.  

1. **defaultdict** 객체  
    존재하지 않는 키를 조회할 경우 에러 대신 디폴트 값을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다.  

    ```python
    import collections

    a = collections.defaultdict(int)
    >>> a['A'] = 5
    >>> a['B'] = 4
    >>> a
    defaultdict(<class 'int'>, {'A': 5, 'B': 4})
    ```  

    다음과 같이 컬렉션 모듈 임포트 하고 디폴트 값이 int형인 defaultdict 객체를 a에 할당한다. 일반적 쓰임은 기본 딕셔너리와 동일하다. 

    ```python
    >>> a['C']
    0
    >>> a
    defaultdict(<class 'int'>, {'A': 5, 'B': 4, 'C': 0})
    ```  

    실제로는 없는 키인 'C'를 조회했다. 원래라면 없는 키를 조회하여 KeyError가 발생하지만 defaultdict는 에러 대신 디폴트 값(0) 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다.  

2. **Counter** 객체  
    아이템에 대한 개수를 계산해 딕셔너리로 계산한다. <u>key에는 아이템 값이, value에는 그 아이템의 개수가 들어간 딕셔너리</u>를 생성한다.   

    백문이 불여일견.  

    ```python
    a = [1,2,3,4,5,5,5,6,6]
    >>> b=collections.Counter(a)
    >>> b
    Counter({5: 3, 6: 2, 1: 1, 2: 1, 3: 1, 4: 1})
    ```
    다음처럼 key값의 아이템의 개수를 value로 가지는 딕셔너리를 돌려준다.  
    그렇다면 가장 빈도 높은 요소를 따로 추출하는 기능도 제공할까? ㅇㅇ! 
    ```Python
    >>> b.most_common(1)
    [(5, 3)]
    >>> b.most_common(2)
    [(5, 3), (6, 2)]
    ```
    다음처럼 most_common(n) 함수를 쓰면 n개의 가장 빈번히 나타나는 요소들의 key-value를 튜플로 가지는 리스트를 리턴한다.  

3. OrderedDict 객체  
    입력 순서를 보존하는 딕셔너리이다.  
    3.7+ 버전에서는 이제 입력 순서가 보존되므로 쓸 일이 없다. '아니 버전이 다를 수 있으므로 유의할 필요가 있지 않을까?' 싶지만,  
    21년 12월에 작성하는 지금도 대부분 테스트가 3.7+을 사용한다 하니 내가 제대로 테스트 치를 ~~이미 전역한~~ 미래에는 버전 유의도 할 필요 없을 것이다.

<br>
<br>
여기 있는 것만으로는 빈 심화 설명 몇개 있겠지만 차차 할 다음 포스트에서 언급하면서 살 붙여나가자.  

---