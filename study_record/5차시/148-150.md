## 937. Reorder Log Files  : https://leetcode.com/problems/reorder-data-in-log-files/submissions/  


내 풀이 

```python
class Solution(object):
    def reorderLogFiles(self, logs):
        """
        :type logs: List[str]
        :rtype: List[str]
        """
        numeric_list = [] #숫자 로그만을 담을 리스트
        idx=0
        for log in logs:
            tmp_list = log.split()

            if tmp_list[1].isnumeric() :  # 숫자는 어차피 입력순이고 문자 뒤에 있으므로 따로 뺴줘서 나중에 문자정렬 결과물 뒤에 붙이기
                numeric_list.append(log)
                del logs[idx]
            idx += 1

        numeric_list.sort() # 같은 숫자인 경우 구분자 기준 정렬
#--------------------------------------------------------------------------------- 문자 정렬 + 같은경우 구분자 정렬 생각못해내고 ㅈㅈ
```  

풀이 하나만 있음.  

1. 람다와 +연산자 이용:  

    ```python
    def reorderLogFiles(self, logs): 
        letters, digits = [], []
        for log in logs:
            if log.split()[1].isdigit():
                digits.append(log)
            else: 
                letters.append(log)

        letters.sort(key= lambda x: (x.split()[1:], x.split()[0]))
        return letters + digits
    ```


    문자로그와 숫자로그를 따로 구분하여 나중에 숫자를 문자 뒤에 +연산자로 이어붙이는 아이디어는 내 생각과 동일.  

    이후 리스트의 sort 메서드로 정렬하는데 **패러미터로 key옵션에 함수를 넣어 정렬 기준을 임의로 지정**할 수 있다.  

    ### 람다 사용법  

    람다 표현식은 식별자 없이 실행 가능한 함수.  
    리스트 컴프리헨션이 더 깔쌈하지만 가끔 람다가 더 편한 경우도 있음, 지금처럼.  

    우리는 각 요소의 번호 순 정렬이 아니라 그 뒤의 문자 순 정렬을 원하며, 문자가 동일한 경우에만 그 앞 번호순으로 정렬되는 기능을 원한다.  
    이 때 위 람다 식처럼 정렬 우선 순위를 정해줄 수 있다.  

    ```python
    # 기본적인 sort에선, 그냥 기본 할당.
    >>> a = [(1, 2), (5, 1), (0, 1), (5, 2), (3, 0)]

    >>> b=sorted(a)
    >>> b
    [(0, 1), (1, 2), (3, 0), (5, 1), (5, 2)]

    #key 인자에 람다함수로 정렬 우선순위를 정해줌.
    >>> c=sorted(a, key = lambda x: x[1])
    >>> c
    [(3, 0), (5, 1), (0, 1), (1, 2), (5, 2)]

    # 비교할 아이템이 여러 개면 튜플로 그 아이템 중 우선순위 지정가능하다.
    e = sorted(a, key = lambda x : (x[0], x[1]))

    # 비교할 아이템이 요소가 복수 개일 경우, 튜플로 우선순위를 정해줄 수 있다.
    # -를 붙이면, 현재와 반대차순으로 정렬된다.
    letters.sort(key= lambda x: (x.split()[1:], x.split()[0]))
    ```

    