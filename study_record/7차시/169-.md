# 7장 배열  

자료구조는 크게  

**메모리 공간 기반의 연속(contiguous) 방식**과 

**포인터 기반의 연결(link) 방식**으로 나뉜다.  

배열은 *연속 방식*의 가장 기본이 되는 자료형이다. 연결 리스트는 *연결 방식*의 가장 기본이 되는 자료형이다.

스택, 큐 같은 추상 자료형(ADT)의 실제 구현 대부분은 배열 또는 연결 리스트를 기반으로 한다.  

7장에서는 메모리 공간 기반의 연속 방식의 기초 자료형인 배열을 알아본다.  

---  

C언어 기준으로 배열은 **크기를 지정하고 해당 크기만큼의 연속 메모리 공간을 할당받는 작업을 수행하는 자료형**이다.  

크기는 고정이므로 한번 생성한 배열은 크기 변경이 불가능하다.  

```c
int array[5] = {0,1,2,3,4};
# 4bytes의 정수형을 담는 크기 5인 배열의 총 메모리는 20bytes.
```  

배열의 장점은 어느 위치에나 O(1)에 조회할 수 있다는 것이다. 해당 위치의 메모리 주소를 조회하기만 하면 되기 때문이다.  

배열의 단점은 고정된 크기만큼을 가진다는 것이다. 너무 작거나 너무 클 때 크기 수정이 불가능하다는 것은 꽤 불편할 것이다.  

이런 단점을 보완하고자 크기를 지정치 않고 자동으로 Resizing하는 동적 배열이 등장했다. 파이썬의 리스트가 바로 동적 배열에 해당한다.  

동적 배열의 조회 또한 O(1)에 가능하다. 가끔 공간이 차게되면 새 메모리 공간에 더 큰 크기의 배열을 할당하고 기존 데이터 복사하는 작업 등 O(n)이 되는 최악의 경우도 있기도 하다. 그래도 분할 상환 분석에 따른 입력 시간은 여전히 O(1)이다.  

---  

## 1. Two Sum: https://leetcode.com/problems/two-sum/  

최적화 기법이 여러 개라 매우 중요한 빈출 소재.  

1. 브루트 포스 (내 풀이): 

```python 
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i, j] 
    # 그냥 바로 리스트에 담아서 통으로 리턴하는게 내꺼보다 더 깔쌈하다.
```  

시간 복잡도는 O(n<sup>2</sup>)이다. 맅콛에서도 O(n<sup>2</sup>) 미만으로 최적화 가능함? 이렇게 물어보면서 다른 풀이 껀덕지 요구함.  

2 - 1. in을 이용한 보수 탐색 :

```python
from typing import List


class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i, n in enumerate(nums):
            complement = target - n

            if complement in nums[i + 1:]:
                return [nums.index(n), 
                nums[i + 1:].index(complement) + (i + 1)]
```

결과 조건은 **2개**의 인덱스이다.

인덱스 접근은 enumerate 함수로 하는 것에 주목.  

nums의 요소 하나하나를 target에서 빼서 보수를 만들고 in을 이용해 내부에 보수가 있는지 탐색한다.  

보수가 존재한다면 탐색한 num요소의 인덱스와 보수의 인덱스가 정답이다.  

in 연산은 내장에 구현된 것으로 파이썬 레벨에서 반복문 돌리는 등.. 의 작업(1번풀이)보다 훨씬 빠르다.  

마지막에 인덱스 리턴 구문에서 i+1을 하는 이유는 index 메서드를 돌리는 객체는 nums[i+1:]이기 때문이다. 원본보다 i+1 만큼 땡겨져서 본래의 인덱스 값보다 i+1만큼 작아졌기 때문이다.


3. 첫 번째 수를 뺀 결과 키 조회 :  

비교나 탐색 대신 한 번에 정답을 찾아보자.

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        nums_map = {}
        # 키와 값을 바꿔서 딕셔너리로 저장
        for i, num in enumerate(nums):
            nums_map[num] = i

        # 타겟에서 첫 번째 수를 뺀 결과를 키로 조회
        for i, num in enumerate(nums):
            if target - num in nums_map and i != nums_map[target - num]:
                return [i, nums_map[target - num]]
```
딕셔너리는 조회, 추가 등 관련 연산 대부분이 O(1)이다. 
우선 nums_map이라는 딕셔너리에 num - index 을 각각 넣는다.  
그리고 보수가 해쉬에 있으면서 그 보수의 인덱스가 현재 자기 자신의 인덱스가 아닐 때 리턴한다.  

if문의 2번째 조건문은 예를 들어 nums = [3,2,4], target = 6 일때 3을 두번 지정하는 오류를 제외해야 하기 때문이다. 

2번 풀이보다 더 최적화됐기 때문에 훨씬 더 빠르게 돌아간다. 

4. 3번을 더 이쁘게 :

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        nums_map = {}
        # 하나의 `for`문으로 통합
        for i, num in enumerate(nums):
            if target - num in nums_map:
                return [nums_map[target - num], i]
            nums_map[num] = i
```

5. 투 포인터로는 가능할까? :

```python
from typing import List
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1
        while not left == right:
            # 합이 타겟보다 크면 오른쪽 포인터를 왼쪽으로
            if nums[left] + nums[right] < target:
                left += 1
            # 합이 타겟보다 작으면 왼쪽 포인터를 오른쪽으로
            elif nums[left] + nums[right] > target:
                right -= 1
            else:
                return [left, right]
```





