
#인덴트: 공식 가이드 PEP8에 따라 공백 4칸을 원칙으로 한다.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

#네이밍 컨벤션: snake_case를 따른다. 파이썬 PEP8 및 철학에 따라 스네이크 코딩을 지향
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

#타입 힌트: 3.5버전부터 타입 지정 가능한 타입 힌트 사용가능.

a: str = "1"
b: int = 1

    #기존 함수는 다음과 같이 표기하였다. 패러미터의 타입을 모르므로 넘겨야 하는 것이 숫자인지, 문자인지 알 수 없으며 리턴 타입이 무엇인지도 알 수 없다.
def fn(a): 
    pass


    #타입 힌트를 다음과 같이 사용하여 패러미터 타입과 리턴타입을 definite하게 명시해주자
def fn(a: int) ->bool : 
    pass
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

#리스트 컨프리헨션: 기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문.

    #파이썬은 map, filter같은 함수형 기능을 지원하며 다음과 같은 람다 표현식도 지원함.
mf = list(map(lambda x: x+10, [1,2,3]))
    #그러나 리스트 컴프리헨션이 더 유용한 파이썬의 대표적인 특징이다.
    #다음은 홀수인 경우 2를 곱해 출력하라는 리스트 컴프리헨션이다

# print([n*2 for n in range(1, 10+1) if n%2 ==1])
# print("\n\n")
    #리스트 컴프리헨션은 딕셔너리도 가능하다.
# a = {}
# for key, value in original.items():
#     a[key]= value                     같은 구문을
# a = {key: value for key, value in original.items()} 로 바꿔쓸 수 있다.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------


#제너레이터: 루프의 반복 동작을 제어할 수 있는 루틴 형태, iterator을 생성시켜주는 함수

    #yield는 임시 리턴구문, next는 다음 값을 생성하는 구문.
# def get_natural_number():
#     n = 0
#     while True:
#         n+=1
#         yield n
# g = get_natural_number()

# for _ in range(0,100):
#     print(next(g))

    #제너레이터는 여러 타입의 값을 하나의 함수에서 생성가능하게 함.

# def generator():
#     yield 1
#     yield 'string'
#     yield True
# g = generator()
# print(g)
# print(next(g))
# print(next(g))
# print(next(g))
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

#range 함수
    #제너레이터의 방식 활용하는 대표적 함수.
    #다음은 숫자 100만개를 생성하는 두가지 방법

a = [n for n in range(1000000)]
b = range(1000000)
    #중요한 것! -> a는 생성된 값이 담겨있고 b는 생성해야 한다는 조건만 존재.
    #둘 사이의 메모리 점유율이 크게 다를 것이다.
    #그러나 b는 인덱스에 접근하는 등 a 사용법 그대로 쓸 수 있다!
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

#enumerate 함수: 여러 자료형을 인덱스를 포함한 enumerate 객체로 리턴한다.
a = [1,2,3,4,5]
# print(list(enumerate(a)))
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

#// 나눗셈 연산자: 몫을 구하는 연산자, 사실 이전버전 파이썬의 나눗셈 기본 연산자이며 c언어와 동일한 기능이었다.
# print(f"{5/3}, {5//3}")

# +) 몫과 나머지를 동시에 구하려면 divmod()함수를 사용하면 편리하다.
print(divmod(5,3))
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

#print(): 밑바닥부터 시작하는 디버깅 도구. 적어도 실행결과를 stdout으로 출력해주지 않는 곳은 없으므로.. 사용법 잘 익혀두자.
    #print(a, b) 콤마가 구분자 역할인 경우 디폴트로 공백 하나가 들어가 띄어쓰기로 값 구분해준다.
    #print(a,b, sep= ',') sep파라미터로 구분자 임의 설정 가능.
    #print함수는 항상 줄바꿈을 함, 따라서 수평 출력시 sep = ' '로 하면 문제없음.
    
    #join함수: '.'.join(a) 꼴로 쓰이며 인자로 들어온 객체의 요소 사이사이에 설정한 구분자를 넣어 리턴한다.
    #따라서 리스트 출력시 join함수를 이용해서 다음처럼 ㄱㄱ
a = ['a', 'b', 'c']
print(' '.join(a)) #공백없이 ''꼴이면 그냥 하나의 문자열 만들어버리는 기능을 함!

    #f-string 기법: 변수를 템플릿 사용하듯 인라인으로 삽입하는 기법, 3.6버전 이상에서만 지원하는 최신기법.
a:int = 4
print(f'{1+3}  == a의 값인 {a}')
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

#pass: 목업 인터페이스부터 구현하기 위해 아무 역할을 하지않음을 나타내는 구문, NULL 연산. 목업(Mock-up)은 실제품 제작 이전의 시제품 작업 프로세스 및 결과물을 뜻함.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

#local(): 로컬에 선언된 모든 변수를 조회하는 명령 -> 디버깅에 도움 why? 변수명을 일일이 찾을 필요 없이 로컬 스코프에 정의된 모든 변수를 출력하기 때문.
    #pprint 모듈을 임포트하여 깔끔하게 출력하자 -> pprint.pprint(local())
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

#구글 파이썬 스타일 가이드: 
    #1. 함수 기본 값으로 가변 객체([list], {dict}, set)를 사용치 말아야 한다. 객체 수정 시 기본값이 변경되므로.. None을 명시적으로 할당해주는게 낫다.

def foo(a, b=[]):
    pass  #NOOOOOOOOOOOOOOOO 

def foo2(a, b=None): 
    if b == None: 
        b=[]

    #2. True, False 판별 시 암시적 방법 사용이 간결하고 가독성 높인다. if foo !=[] 보다는 if foo가 더 낫다는 얘기.

